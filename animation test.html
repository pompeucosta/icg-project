<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body
        {
            margin: 0%;
        }
    </style>
</head>
<body>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        let mixer,scene,renderer,camera,clock,action = [];
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xbfd1e5);
        clock = new THREE.Clock();
        camera = new THREE.PerspectiveCamera(75,window.innerWidth / window.innerHeight,0.2,5000);
        camera.position.z += 5;
        camera.position.y += 1.5;

        let dirLight = new THREE.DirectionalLight(0xffffff,1);
        dirLight.color.setHSL(0.1,1,0.95);
        dirLight.position.set(0,5,0);
        dirLight.position.multiplyScalar(100);
        scene.add(dirLight);
        dirLight.castShadow = true;
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setClearColor(0xbfd1e5);
        renderer.setSize(window.innerWidth,window.innerHeight);
        document.body.appendChild(renderer.domElement);
        window.addEventListener("keydown",keydownHandler);
        window.addEventListener("keyup",keyupHandler);
        let animationPlaying = "",animationToPlay = "";
        let animationFinished = true;
        let animationsMap = new Map();

        let attacking = false;
        let running = false;

        const loader = new GLTFLoader();
            loader.load(
                // resource URL
                './char test/character.glb',
                // called when the resource is loaded
                function ( gltf ) {
                    const model = gltf.scene;
                    model.traverse(function(object)
                    {
                        if(object.isMesh)
                            object.castShadow = true;
                    });
                    scene.add( model );
                    mixer = new THREE.AnimationMixer(model);
                    mixer.addEventListener('finished', ( event ) => {
                        animationFinished = true;
                    });

                    console.log(mixer);
                    clips = gltf.animations;
                    clips.forEach((a) => 
                    {
                        animationsMap.set(a.name,mixer.clipAction(a));
                    });

                    const slashAnim = animationsMap.get("Slash");
                    slashAnim.setLoop(THREE.LoopOnce);
                    slashAnim.clampWhenFinished = true;
                    action = animationsMap.get("IDLE");
                    console.log(gltf.animations);
                    animationToPlay = "IDLE";
                    animationPlaying = "IDLE";
                    action.play();
                },
                // called while loading is progressing
                function ( xhr ) {

                    console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                },
                // called when loading has errors
                function ( error ) {

                    console.log( error );

                }
            );

        animate();

        function animate()
        {
            let deltaTime = clock.getDelta();
            requestAnimationFrame(animate);
            update(deltaTime);
            renderer.render(scene,camera);
        }

        function keydownHandler(event)
        {
            event.preventDefault();
            let key = event.key;

            switch(key)
            {
                case "q":
                    attacking = true;
                    break;

                case "w":
                    running = true;
                    break;
            }
        }

        function keyupHandler(event)
        {
            let key = event.key;

            switch(key)
            {
                case "q":
                    attacking = false;
                    break;

                case "w":
                    running = false;
                    break;
            }
        }

        function update(delta)
        {
            if(animationFinished)
            {
                const currentAnimation = animationsMap.get(animationPlaying);
                let nextAnimation;

                if(!running && !attacking)
                {
                    nextAnimation = animationsMap.get("IDLE");
                    animationToPlay = "IDLE";
                }
                else
                {
                    animationToPlay = attacking ? "Slash" : "Running.001";
                    nextAnimation = animationsMap.get(animationToPlay);
                }
                
                if(currentAnimation != nextAnimation)
                {
                    if(currentAnimation)
                        currentAnimation.fadeOut(0.5);
                    nextAnimation.reset().fadeIn(0.5).play();
                    animationPlaying = animationToPlay;
                } 
                else if(animationToPlay == "Slash" && animationFinished)
                {
                    currentAnimation.reset();
                    animationFinished = false;
                }
            }

            if(mixer)
                mixer.update(delta)
        }
    </script>
</body>
</html>