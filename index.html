<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Adventure Game</title>
    <style>
        body
        {
            margin: 0;
        }
    </style>
</head>
<body>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>
    <script src="./ammo.js"></script>
    <script type="module">
        //https://raw.githubusercontent.com/bulletphysics/bullet3/master/docs/Bullet_User_Manual.pdf
        //https://threejs.org/docs/index.html?q=light#api/en/lights/DirectionalLight
        //https://threejs.org/examples/?q=sun#webgl_shaders_sky
        //https://stackoverflow.com/questions/38052621/moving-the-camera-in-the-direction-its-facing-with-threejs
        //https://github.com/mrdoob/three.js/blob/master/examples/webgl_multiple_views.html
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { Sky } from 'three/addons/objects/Sky.js';

        //THREE js variables
        let scene,renderer,playerObject,monsterObject,sky,directionalLight,clock;

        //AMMMO variables
        let physicsWorld,ammoTmpTrans,ammoTmpPos,ammoTmpQuat;

        //Events variables
        let mouseDown = false,mouseX,mouseY;

        //THREE js constants
        const playerPivot = new THREE.Object3D();
        const monsterPivot = new THREE.Object3D();
        const playerCameraPivot = new THREE.Object3D();
        const monsterCameraPivot = new THREE.Object3D();
        const sun = new THREE.Vector3();

        const effectController = {
					turbidity: 10,
					rayleigh: 3,
					mieCoefficient: 0.005,
					mieDirectionalG: 0.7,
					elevation: 0,
					azimuth: 180,
					exposure: 0.5
				};

        //AMMO constants
        const rigidBodies = [];

        //Player
        let playerCameraRotation = {left:0,right:0,up:0,down:0};
        let monsterCameraRotation = {left:0,right:0,up:0,down:0};
        let playerAttacking = false,playerRunning = false,animationFinished = true,animationsMap = new Map(),animationPlaying = "",playerMixer,playerCamera;

        //Monster
        let monsterAttacking = false,monsterRunning = false,monsterAnimationFinished = true,monsterIdleFinished = true,monsterAnimationsMap = new Map(),monsterAnimationPlaying = "",monsterMixer,monsterCamera;

        Ammo().then(start);

        function start()
        {
            ammoTmpTrans = new Ammo.btTransform();

            setupPhysicsWorld();
            setupGraphics();
            createMap();
            createPlane();
            loadPlayer(0,0,0);
            loadMonster(0,0,30);
            setupHandlers();
            renderFrame();
        }

        function setupHandlers()
        {
            window.addEventListener("keydown",keydownHandler);
            window.addEventListener("keyup",keyupHandler);
            window.addEventListener("resize",resize);
        }

        function keydownHandler(event)
        {
            event.preventDefault();
            if(event.key == "w")
            {
                playerRunning = true;
            }
            else if(event.key == "q")
            {
                playerAttacking = true;
            }
            else if(event.key == "a")
            {
                playerCameraRotation.left = 1;
            }
            else if(event.key == "d")
            {
                playerCameraRotation.right = 1;
            }
            else if(event.key == "e")
            {
                playerCameraRotation.up = 1;
            }
            else if(event.key == "r")
            {
                playerCameraRotation.down = 1;
            }
            else if(event.key == "ArrowLeft")
            {
                monsterCameraRotation.left = 1;
            }
            else if(event.key == "ArrowRight")
            {
                monsterCameraRotation.right = 1;
            }
            else if(event.key == "ArrowUp")
            {
                monsterRunning = true;
            }
            else if(event.key == "PageUp")
            {
                monsterCameraRotation.up = 1;
            }
            else if(event.key == "PageDown")
            {
                monsterCameraRotation.down = 1;
            }
            else if(event.key == "0")
            {
                monsterAttacking = true;
            }
        }

        function keyupHandler(event)
        {
            if(event.key == "w")
            {
                playerRunning = false;
            }
            else if(event.key == "q")
            {
                playerAttacking = false;
            }
            else if(event.key == "a")
            {
                playerCameraRotation.left = 0;
            }
            else if(event.key == "d")
            {
                playerCameraRotation.right = 0;
            }
            else if(event.key == "e")
            {
                playerCameraRotation.up = 0;
            }
            else if(event.key == "r")
            {
                playerCameraRotation.down = 0;
            }
            else if(event.key == "ArrowLeft")
            {
                monsterCameraRotation.left = 0;
            }
            else if(event.key == "ArrowRight")
            {
                monsterCameraRotation.right = 0;
            }
            else if(event.key == "ArrowUp")
            {
                monsterRunning = false;
            }
            else if(event.key == "PageUp")
            {
                monsterCameraRotation.up = 0;
            }
            else if(event.key == "PageDown")
            {
                monsterCameraRotation.down = 0;
            }
            else if(event.key == "0")
            {
                monsterAttacking = false;
            }
        }

        function rotateCamera(characterObject,characterCameraPivot,deltaX, deltaY)
        {
            characterObject.rotation.y += deltaX / 500;
            characterCameraPivot.rotation.x = clamp((characterCameraPivot.rotation.x + deltaY / 500),-0.66,-0.136);
        }

        function clamp(number,min,max)
        {
            return Math.min(max,Math.max(number,min));
        }

        function  resize()
        {
            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function setupPhysicsWorld()
        {
            const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
            const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
            const overlappingPairCache = new Ammo.btDbvtBroadphase();
            const solver = new Ammo.btSequentialImpulseConstraintSolver();

            physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher,overlappingPairCache,solver,collisionConfiguration);
            physicsWorld.setGravity(new Ammo.btVector3(0,-100,0));
        }

        function setupGraphics()
        {
            clock = new THREE.Clock();

            scene = new THREE.Scene();

            sky = new Sky();
            sky.scale.setScalar( 450000 );
            scene.add(sky);

            directionalLight = new THREE.DirectionalLight(0xffffff);
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth,window.innerHeight);
            document.body.appendChild(renderer.domElement);

            renderer.shadowMap.enable = true;
            renderer.toneMappingExposure = effectController.exposure;
        }

        function createMap()
        {
            const loader = new GLTFLoader();
            loader.load(
                './test/map.gltf',
                function (gltf) {
                    scene.add( gltf.scene );
                },
                function (xhr) {
                    console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
                },
                function (error) {
                    console.log( error );
                }
            );

            createWalls();
            createTreeColliders();
            createTreeLogColliders();
            createHouseCollider();
            createTorches();
        }

        function createPlane()
        {
            const pos = {x:0, y:-1, z:0};
            const scale = {x:800, y:2, z:800};
            const mass = 0;
            createBoxCollider(pos.x,pos.y,pos.z,scale.x,scale.y,scale.z,mass);
        }

        function createWalls()
        {
            createWall(0,0,90.24,300,300,1);
            createWall(0,0,-37.02,300,300,1);
            createWall(-100,0,0,1,300,300);
            createWall(70,0,0,1,300,300);
        }

        function createWall(posX,posY,posZ,scaleX,scaleY,scaleZ)
        {
            const mass = 0;
            createBoxCollider(posX,posY,posZ,scaleX,scaleY,scaleZ,mass);
        }

        function createTreeColliders()
        {
            const coords = [
                {x:-33,z:-10},
                {x:-33,z:26},
                {x:-44,z:40},
                {x:-28,z:54},
                {x:-12.5,z:68.5},
                {x:-21.5,z:82.5},
                {x:-29.9,z:70.4},
                {x:-44.3,z:75.4},
                {x:-44.3,z:60.0},
                {x:-58.4,z:67.2},
                {x:-73.8,z:73.9},
                {x:-73.8,z:56.8},
                {x:-60,z:49},
                {x:-72.9,z:35},
                {x:-89,z:35},
                {x:-89.4,z:17.7},
                {x:-74,z:-0.8},
                {x:-68,z:17},
                {x:-90,z:-0.7},
                {x:-71,z:-13},
                {x:-50,z:-12},
                {x:-59,z:3.4},
                {x:-43,z:9},
                {x:-54,z:27},
                {x:-12,z:-19.8},
                {x:8,z:-19},
                {x:24,z:-18},
                {x:24,z:-31},
                {x:39,z:-31.5},
                {x:54,z:-31.6}
            ]

            coords.forEach((coord) =>
            {
                createTreeCollider(coord.x,0,coord.z);
            });

        }

        function createTreeCollider(posX,posY,posZ)
        {
            const mass = 0;
            const radius = 1;
            const height = 20;
            createCapsuleCollider(posX,posY,posZ,mass,radius,height);
        }

        function createHouseCollider()
        {
            const pos = {x:61.5, y:15, z:12};
            const mass = 0;
            const radius = 13;
            const height = 20;
            createCapsuleCollider(pos.x,pos.y,pos.z,mass,radius,height);
        }

        function createTreeLogColliders()
        {
            const mass = 0;
            const radius = 0.5;
            const height = 3;
            const coords =
            [
                {x:-34.7,z:64.2},
                {x:-57,z:58},
                {x:-52.4,z:72.4},
                {x:-70,z:65},//
                {x:-64,z:77.8},
                {x:-86.7,z:53.5},
                {x:-79.8,z:44.3},
                {x:-54.7,z:37.7},
                {x:-82,z:83.7},
                {x:-82.6,z:27.5},
                {x:-40.7,z:50.4},
                {x:-62,z:24.2},
                {x:-74,z:19},
                {x:-77.9,z:11.7},
                {x:85.3,z:7},
                {x:-72,z:6.72},
                {x:-62,z:12.4},
                {x:-49.27,z:14.31},
                {x:-49.35,z:-0.62},
                {x:-63.59,z:-7.8},
                {x:-82.43,z:-12.66},
                {x:-74.23,z:-28.98},
                {x:-61.94,z:-22.49},
                {x:-41.74,z:-20.25},
                {x:-52.35,z:67.74}
            ];

            coords.forEach((coord) =>
            {
                createCapsuleCollider(coord.x,0,coord.z,mass,radius,height);
            });
        }

        function createTreeLogCollider(posX,posY,posZ)
        {
            const mass = 0;
            const radius = 0.5;
            const height = 3;
            createCapsuleCollider(posX,posY,posZ,mass,radius,height);
        }

        function createTorches()
        {
            createTorch(-2,0,-16);
            createTorch(45.8,0,8.6);
            createTorch(45.8,0,18.8);
            createTorch(45.8,0,65);
            createTorch(-2,0,65);
            createTorch(-2,0,24.5);
        }

        function createTorch(posX,posY,posZ)
        {
            const loader = new GLTFLoader();
            loader.load(
            './t/outdoor_torch.glb',
            function (gltf) {
                const model = gltf.scene;
                model.position.set(posX,posY + 4,posZ)
                model.scale.set(4,4,4);
                model.traverse(function(object)
                {
                    if(object.isMesh)
                        object.castShadow = true;
                });
                scene.add( model );
                const mass = 0;
                const radius = 0.1;
                const height = 13;
                createCapsuleCollider(posX,posY,posZ,mass,radius,height);

                const light = new THREE.PointLight(0xFBB741,2,70,4);
                light.position.set(posX,10 + posY,posZ);
                scene.add( light );

            },
            function (xhr) {
                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            function (error) {
                console.log( error );
            }
            );
        }

        function loadPlayer(posX,posY,posZ)
        {
            const loader = new GLTFLoader();
            loader.load(
                './char test/character.glb',
                function ( gltf ) {
                    const playerModel = gltf.scene;
                    playerModel.traverse(function(object)
                    {
                        if(object.isMesh)
                        {
                            object.castShadow = true;
                            object.receiveShadow = true;
                        }
                    });
                    createPlayer(posX,posY,posZ,playerModel);
                    playerMixer = new THREE.AnimationMixer(playerModel);
                    playerMixer.addEventListener('finished', ( event ) => {
                        animationFinished = true;
                    });

                    gltf.animations.forEach((a) =>
                    {
                        animationsMap.set(a.name,playerMixer.clipAction(a));
                    });

                    const slashAnim = animationsMap.get("Slash");
                    slashAnim.setLoop(THREE.LoopOnce);
                    slashAnim.clampWhenFinished = true;
                    const action = animationsMap.get("IDLE");
                    animationPlaying = "IDLE";
                    action.play();
                },
                function ( xhr ) {

                    console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                },
                function ( error ) {

                    console.log( error );

                }
            );

        }

        function createPlayer(posX,posY,posZ,mesh)
        {
            const pos = {x:posX,y:posY,z:posZ};
            const scale = {x:3,y:3,z:3};
            const mass = 80;
            const radius = 1;
            const height = 1;

            playerObject = mesh;
            playerObject.scale.set(scale.x,scale.y,scale.z);
            playerObject.position.set(0,pos.y-1.5,0);
            playerObject.rotation.y += THREE.MathUtils.degToRad(180);
            playerPivot.add(playerObject);
            playerPivot.position.set(pos.x,pos.y,pos.z)
            playerObject.add(playerCameraPivot);

            playerCamera = new THREE.PerspectiveCamera(60,window.innerWidth / window.innerHeight,0.2,5000);
            playerCameraPivot.add(playerCamera);
            playerCamera.position.set(0,5,5);
            playerCamera.lookAt(new THREE.Vector3(0,0,0));
            playerCameraPivot.rotation.y += THREE.MathUtils.degToRad(180);

            scene.add(playerPivot);

            const transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(pos.x,pos.y,pos.z));
            transform.setRotation(new Ammo.btQuaternion(0,0,0,1));
            const motionState = new Ammo.btDefaultMotionState(transform);
            const colShape = new Ammo.btCapsuleShape(radius,height);
            colShape.setMargin(0.05);
            const localInertia = new Ammo.btVector3(0,0,0);
            colShape.calculateLocalInertia(mass,localInertia);

            const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass,motionState,colShape,localInertia);
            const body = new Ammo.btRigidBody(rbInfo);
            body.setFriction(4);
            body.setRollingFriction(10);

            body.setActivationState( 4 );
            physicsWorld.addRigidBody(body);
            body.setAngularFactor(0);

            playerPivot.userData.physicsBody = body;
            rigidBodies.push(playerPivot);

        }

        function loadMonster(posX,posY,posZ)
        {
            const loader = new GLTFLoader();
            loader.load(
                './monster test/monster.glb',
                function ( gltf ) {
                    const monsterModel = gltf.scene;
                    monsterModel.traverse(function(object)
                    {
                        if(object.isMesh)
                        {
                            object.castShadow = true;
                            object.receiveShadow = true;
                        }
                    });
                    createMonster(posX,posY,posZ,monsterModel);
                    monsterMixer = new THREE.AnimationMixer(monsterModel);
                    monsterMixer.addEventListener('finished', ( event ) => {
                        monsterAnimationFinished = true;
                        monsterIdleFinished = true;
                    });

                    gltf.animations.forEach((a) =>
                    {
                        monsterAnimationsMap.set(a.name,monsterMixer.clipAction(a));
                    });

                    const attackAnim = monsterAnimationsMap.get("Attack");
                    attackAnim.setLoop(THREE.LoopOnce);
                    attackAnim.clampWhenFinished = true;
                    const idleAnim = monsterAnimationsMap.get("IDLE");
                    idleAnim.setLoop(THREE.LoopOnce);
                    idleAnim.clampWhenFinished = true;
                    const idleAnim2 = monsterAnimationsMap.get("Breathing_IDLE");
                    idleAnim2.setLoop(THREE.LoopOnce);
                    idleAnim2.clampWhenFinished = true;
                },
                function ( xhr ) {

                    console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                },
                function ( error ) {

                    console.log( error );

                }
            );
        }

        function createMonster(posX,posY,posZ,mesh)
        {
            const pos = {x:posX,y:posY,z:posZ};
            const scale = {x:5,y:5,z:5};
            const mass = 80;
            const radius = 1;
            const height = 1;

            monsterObject = mesh;
            monsterObject.scale.set(scale.x,scale.y,scale.z);
            monsterObject.position.set(0,pos.y-1.5,0);
            monsterPivot.add(monsterObject);
            monsterPivot.position.set(pos.x,pos.y,pos.z);

            monsterObject.add(monsterCameraPivot);

            monsterCamera = new THREE.PerspectiveCamera(60,window.innerWidth / window.innerHeight,0.2,5000);
            monsterCameraPivot.add(monsterCamera);
            monsterCamera.position.set(0,5,5);
            monsterCamera.lookAt(new THREE.Vector3(pos.x,0,pos.z));
            monsterCameraPivot.rotation.y += THREE.MathUtils.degToRad(180);

            scene.add(monsterPivot);

            const transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(pos.x,pos.y,pos.z));
            transform.setRotation(new Ammo.btQuaternion(0,0,0,1));
            const motionState = new Ammo.btDefaultMotionState(transform);
            const colShape = new Ammo.btCapsuleShape(radius,0.5);
            colShape.setMargin(0.05);
            const localInertia = new Ammo.btVector3(0,0,0);
            colShape.calculateLocalInertia(mass,localInertia);

            const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass,motionState,colShape,localInertia);
            const body = new Ammo.btRigidBody(rbInfo);
            body.setFriction(4);
            body.setRollingFriction(10);

            body.setActivationState( 4 );
            physicsWorld.addRigidBody(body);
            body.setAngularFactor(0);

            monsterPivot.userData.physicsBody = body;
            rigidBodies.push(monsterPivot);
        }

        function createCapsuleCollider(posX,posY,posZ,mass,radius,height)
        {
            return createCollider(posX,posY,posZ,mass,new Ammo.btCapsuleShape(radius,height));
        }

        function createBoxCollider(posX,posY,posZ,scaleX,scaleY,scaleZ,mass)
        {
            return createCollider(posX,posY,posZ,mass,new Ammo.btBoxShape(new Ammo.btVector3(scaleX * 0.5,scaleY * 0.5,scaleZ * 0.5)));
        }

        function createCollider(posX,posY,posZ,mass,colShape)
        {
            const pos = {x:posX,y:posY,z:posZ};
            const transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(posX,posY,posZ));
            transform.setRotation(new Ammo.btQuaternion(0,0,0,1));

            const motionState = new Ammo.btDefaultMotionState(transform);

            const localInertia = new Ammo.btVector3(0,0,0);
            colShape.setMargin(0.05);
            colShape.calculateLocalInertia(mass,localInertia);

            const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass,motionState,colShape,localInertia);
            const body = new Ammo.btRigidBody(rbInfo);
            body.setFriction(4);
            body.setRollingFriction(10);
            physicsWorld.addRigidBody(body);
            return body;
        }

        function move(body,camera,running,attacking)
        {
            if(!(running && !attacking))
                return;

            const speed = 30;
            const characterPos = body.getWorldTransform().getOrigin();

            let direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize().multiplyScalar(speed);
            body.setLinearVelocity(new Ammo.btVector3(direction.x,0,direction.z));

        }

        function updatePhysics(deltaTime)
        {
            physicsWorld.stepSimulation(deltaTime,10);

            for(let i = 0; i < rigidBodies.length; i++)
            {
                const objThree = rigidBodies[i];
                const objAmmo = objThree.userData.physicsBody;
                const ms = objAmmo.getMotionState();

                if(ms)
                {
                    ms.getWorldTransform(ammoTmpTrans);
                    const p = ammoTmpTrans.getOrigin();
                    const q = ammoTmpTrans.getRotation();
                    objThree.position.set(p.x(),p.y(),p.z());
                    objThree.quaternion.set(q.x(),q.y(),q.z(),q.w());
                }
            }
        }

        function updateDayNightCycle(delta)
        {
            const speed = 10;
            const uniforms = sky.material.uniforms;
            const phi = THREE.MathUtils.degToRad(90 - effectController.elevation);
            const theta = THREE.MathUtils.degToRad(effectController.azimuth);

            sun.setFromSphericalCoords(1,phi,theta);

            uniforms['sunPosition'].value.copy(sun);
            directionalLight.position.copy(sun);
            effectController.elevation += delta * speed;
        }

        function updatePlayerMixer(delta)
        {
            if(animationFinished)
            {
                let playerMove = playerRunning && !playerAttacking;
                const currentAnimation = animationsMap.get(animationPlaying);
                let nextAnimation,animationToPlay;

                if(!playerRunning && !playerAttacking)
                {
                    nextAnimation = animationsMap.get("IDLE");
                    animationToPlay = "IDLE";
                }
                else
                {
                    animationToPlay = playerAttacking ? "Slash" : "Running.001";
                    nextAnimation = animationsMap.get(animationToPlay);
                }

                if(currentAnimation != nextAnimation)
                {
                    if(currentAnimation)
                        currentAnimation.fadeOut(0.5);
                    nextAnimation.reset().fadeIn(0.5).play();
                    animationPlaying = animationToPlay;
                }
                else if(animationToPlay == "Slash" && animationFinished)
                {
                    currentAnimation.reset();
                    animationFinished = false;
                }
            }

            if(playerMixer)
                playerMixer.update(delta)
        }

        function updateMonsterMixer(delta)
        {
            if(monsterAnimationFinished)
            {
                const currentAnimation = monsterAnimationsMap.get(monsterAnimationPlaying);
                let nextAnimation,animationToPlay = "";

                if(!monsterRunning && !monsterAttacking)
                {
                    if(monsterIdleFinished)
                    {
                        const rnd = Math.floor(Math.random() * 3);
                        animationToPlay = rnd == 0 ? "IDLE" : "Breathing_IDLE";
                    }
                    else
                        animationToPlay = monsterAnimationPlaying;
                }
                else
                    animationToPlay = monsterAttacking ? "Attack" : "Walk";

                nextAnimation = monsterAnimationsMap.get(animationToPlay);
                if(!nextAnimation)
                    return;

                if(currentAnimation != nextAnimation)
                {
                    if(currentAnimation)
                        currentAnimation.fadeOut(0.5);

                    nextAnimation.reset().fadeIn(0.5).play();
                    monsterAnimationPlaying = animationToPlay;
                    monsterIdleFinished = true;
                }
                else if(((animationToPlay == "Attack" && monsterAnimationFinished) || ((animationToPlay == "IDLE" || animationToPlay == "Breathing_IDLE") && monsterIdleFinished)))
                {
                    if(currentAnimation)
                        currentAnimation.reset();

                    if(animationToPlay == "Attack")
                        monsterAnimationFinished = false;
                    else
                        monsterIdleFinished = false;
                }
            }

            if(monsterMixer)
                monsterMixer.update(delta)
        }

        function render(camera,left)
        {
            const bottom = Math.floor(window.innerHeight * 0);
            const width = Math.floor(window.innerWidth * 0.5);
            const height = Math.floor(window.innerHeight * 1);

            renderer.setViewport(left,bottom,width,height);
            renderer.setScissor(left,bottom,width,height);
            renderer.setScissorTest(true);

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.render(scene,camera);
        }

        function updateCameraRotation(characterObject,cameraPivot,cameraRotation)
        {
            const cameraSpeed = 10;
            const deltaX = (cameraRotation.right - cameraRotation.left) * cameraSpeed;
            const deltaY = (cameraRotation.up - cameraRotation.down) * cameraSpeed;
            rotateCamera(characterObject,cameraPivot,deltaX,deltaY);
        }

        function renderFrame()
        {
            let deltaTime = clock.getDelta();
            move(playerPivot.userData.physicsBody,playerCamera,playerRunning,!animationFinished);
            move(monsterPivot.userData.physicsBody,monsterCamera,monsterRunning,!monsterAnimationFinished);
            updatePhysics(deltaTime);
            updatePlayerMixer(deltaTime);
            updateMonsterMixer(deltaTime);
            updateDayNightCycle(deltaTime);

            if(playerObject)
                updateCameraRotation(playerObject,playerCameraPivot,playerCameraRotation);
            if(monsterObject)
                updateCameraRotation(monsterObject,monsterCameraPivot,monsterCameraRotation);

            if(playerCamera)
                render(playerCamera,Math.floor(window.innerWidth * 0));
            if(monsterCamera)
                render(monsterCamera,Math.floor(window.innerWidth * 0.5));

            requestAnimationFrame(renderFrame);
        }
    </script>
</body>
</html>