<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ENjdO4Dr2bkBIFxQpeoTz1HIcje39Wm4jDKdf19U8gI4ddQ3GYNS7NTKfAdVQSZe" crossorigin="anonymous"></script>
    <title>Simple Adventure Game</title>
    <style>
        body
        {
            margin: 0%;
        }
        .loadingScreen
        {
            z-index: 100;
            height: 100vh;
            width: 100vw;
            position: absolute;
            background: white;
        }
        .score
        {
            position: absolute;
            font-size: 5em;
            color: white;
            top: 5%;
        }
        .my_progressbar
        {
            position: absolute;
            width: 10%;
            margin: 0%;
        }
        #humanScore
        {
            left: 45%;
            right: 55%;  
        }
        #monsterScore
        {
            left: 53%;
            right: 47%;
        }
        .humanBar
        {
            top: 95%;
            left: 37%;
            right: 63%;  
        }
        .monsterBar
        {
            top: 95%;
            left: 53%;
            right: 47%;
        }
        .info
        {
            position: absolute;
            width: 100vw;
            height: auto;
            top: 50%;
            bottom: 50%;
            font-size: 1.5em;
        }
        .settings
        {
            width: 2em;
            height: 2em;
        }
    </style>
</head>
<body>
    <div id="loadingScreen" class="loadingScreen">
        <div class="position-absolute bottom-50 start-50 w-75 translate-middle">
            <div class="progress" role="progressbar" aria-label="Animated striped example" aria-valuenow="75" aria-valuemin="0" aria-valuemax="100">
                <div id="loadingBar" class="progress-bar progress-bar-striped progress-bar-animated bg-success" style="width: 0%"></div>
            </div>
        </div>
        <p class="info text-primary text-center">Loading</p>
    </div>
    <div id="humanScore" class="score">0</div>
    <div id="monsterScore" class="score">0</div>
    <div class="my_progressbar humanBar">
        <div class="progress">
          <div id="humanHealth" class="progress-bar progress-bar-striped progress-bar-animated bg-danger" role="progressbar" style="width:100%">
          </div>
        </div>
    </div>
    <div class="my_progressbar monsterBar">
        <div class="progress">
          <div id="monsterHealth" class="progress-bar progress-bar-striped progress-bar-animated bg-danger" role="progressbar" style="width:100%">
          </div>
        </div>
    </div>
    <button type="button" class="btn btn-primary position-absolute end-0 mt-3 me-3" data-bs-toggle="modal" data-bs-target="#modal">
        <img src="./assets/setting.png" class="settings">
    </button>
    <div class="modal fade" id="modal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="controlsModalLabel">
                        Controls
                    </h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="container-fluid container-sm">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="row fs-5">
                                    Human
                                </div>
                                <div class="row">
                                    <div class="col-md-1">
                                        w <br/> q <br/> e <br/> r <br/> a <br/> d
                                    </div>
                                    <div class="col-md-5">
                                        move forward <br/> attack <br/> rotate camera up <br/> rotate camera down <br/> rotate right <br/> rotate left
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="row fs-5">
                                    Monster
                                </div>
                                <div class="row">
                                    <div class="col-md-3">
                                        arrow up <br/> 0 <br/> page up <br/> page down <br/> arrow left <br/> arrow right <br/>
                                    </div>
                                    <div class="col-md-6">
                                        move forward <br/> attack <br/> rotate camera up <br/> rotate camera down <br/> rotate right <br/> rotate left
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
                </div>
            </div>
        </div>
    </div>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./js/three.module.js",
                "three/addons/": "./js/addons/"
            }
        }
    </script>
    <script src="./js/ammo.js"></script>
    <script type="module">
        //https://github.com/kripken/ammo.js/
        //https://github.com/bulletphysics
        //https://pybullet.org/Bullet/BulletFull/
        //https://threejs.org/docs/index.html#manual/en/introduction/
        //https://threejs.org/examples/?q=sun#webgl_shaders_sky
        //https://stackoverflow.com/questions/38052621/moving-the-camera-in-the-direction-its-facing-with-threejs
        //https://github.com/mrdoob/three.js/blob/master/examples/webgl_multiple_views.html
        //https://stackoverflow.com/questions/71311304/three-js-check-if-position-is-behind-object

        //for a detailed explanation on how i used these website, read the readme on the github page


        
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/GLTFLoader.js';
        import { Sky } from 'three/addons/Sky.js';

        //THREE js variables
        let scene,renderer,playerObject,monsterObject,sky,directionalLight,clock,loadProgress = 0,loadingManager,generalLoad = 0,assetsLoad = 0,resetPos = false;

        //AMMMO variables
        let physicsWorld,ammoTmpTrans,ammoTmpPos,ammoTmpQuat;

        //Events variables
        let mouseDown = false,mouseX,mouseY;

        //THREE js constants
        const playerPivot = new THREE.Object3D();
        const monsterPivot = new THREE.Object3D();
        const playerCameraPivot = new THREE.Object3D();
        const monsterCameraPivot = new THREE.Object3D();
        const sun = new THREE.Vector3();

        const effectController = {
					turbidity: 10,
					rayleigh: 3,
					mieCoefficient: 0.005,
					mieDirectionalG: 0.7,
					elevation: 0,
					azimuth: 180,
					exposure: 0.5
				};

        //AMMO constants
        const rigidBodies = [];

        //Player
        let playerCameraRotation = {left:0,right:0,up:0,down:0};
        let playerAttacking = false,playerRunning = false,animationFinished = true,animationsMap = new Map(),animationPlaying = "",playerMixer,playerCamera,playerHealth = 100,playerDead = false;
        let playerScore = 0;
        const playerDamage = 50;
        
        //Monster
        let monsterCameraRotation = {left:0,right:0,up:0,down:0};
        let monsterAttacking = false,monsterRunning = false,monsterAnimationFinished = true,monsterIdleFinished = true,monsterAnimationsMap = new Map(),monsterAnimationPlaying = "",monsterMixer,monsterCamera,monsterHealth = 100,monsterDead = false;
        let monsterScore = 0;
        const monsterDamage = 50;

        const loadingBar = document.getElementById("loadingBar");

        Ammo().then(start);

        function start()
        {
            ammoTmpTrans = new Ammo.btTransform();

            loadingManager = new THREE.LoadingManager();

            loadingManager.onLoad = function ( ) {
                document.getElementById("loadingScreen").style.visibility = "hidden";
            };

            loadingManager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
                assetsLoad = (itemsLoaded / itemsTotal) * 100;
                updateLoadProgress();
            };

            loadingManager.onError = function ( url ) {
                console.log( 'There was an error loading ' + url );
            };

            setupPhysicsWorld();
            generalLoad = 1/4.0;
            updateLoadProgress();
            setupGraphics();
            generalLoad += 1/4.0;
            updateLoadProgress();
            createMap();
            createPlane();
            loadPlayer(33,0,13.5);
            loadMonster(-87.4,0,47.7);
            setupHandlers();
            generalLoad += 1/4.0;
            updateLoadProgress();
            renderFrame();
            generalLoad += 1/4.0;
            updateLoadProgress();
        }

        function updateLoadProgress()
        {
            loadProgress = generalLoad * 100 * 1/2.0 + assetsLoad * 1 / 2.0;
            // console.log(loadProgress);
            loadingBar.style.width = loadProgress + "%";
        }

        function setupHandlers()
        {
            window.addEventListener("keydown",keydownHandler);
            window.addEventListener("keyup",keyupHandler);
            window.addEventListener("resize",resize);
        }

        function keydownHandler(event)
        {
            event.preventDefault();
            if(event.key == "w")
            {
                playerRunning = true;
            }
            else if(event.key == "q")
            {
                playerAttacking = true;
            }
            else if(event.key == "a")
            {
                playerCameraRotation.left = 1;
            }
            else if(event.key == "d")
            {
                playerCameraRotation.right = 1;
            }
            else if(event.key == "e")
            {
                playerCameraRotation.up = 1;
            }
            else if(event.key == "r")
            {
                playerCameraRotation.down = 1;
            }
            else if(event.key == "ArrowLeft")
            {
                monsterCameraRotation.left = 1;
            }
            else if(event.key == "ArrowRight")
            {
                monsterCameraRotation.right = 1;
            }
            else if(event.key == "ArrowUp")
            {
                monsterRunning = true;
            }
            else if(event.key == "PageUp")
            {
                monsterCameraRotation.up = 1;
            }
            else if(event.key == "PageDown")
            {
                monsterCameraRotation.down = 1;
            }
            else if(event.key == "0")
            {
                monsterAttacking = true;
            }
            else if(event.key == "p")
            {
                console.log(playerPivot.position);
                
            }
        }

        function keyupHandler(event)
        {
            if(event.key == "w")
            {
                playerRunning = false;
            }
            else if(event.key == "q")
            {
                playerAttacking = false;
            }
            else if(event.key == "a")
            {
                playerCameraRotation.left = 0;
            }
            else if(event.key == "d")
            {
                playerCameraRotation.right = 0;
            }
            else if(event.key == "e")
            {
                playerCameraRotation.up = 0;
            }
            else if(event.key == "r")
            {
                playerCameraRotation.down = 0;
            }
            else if(event.key == "ArrowLeft")
            {
                monsterCameraRotation.left = 0;
            }
            else if(event.key == "ArrowRight")
            {
                monsterCameraRotation.right = 0;
            }
            else if(event.key == "ArrowUp")
            {
                monsterRunning = false;
            }
            else if(event.key == "PageUp")
            {
                monsterCameraRotation.up = 0;
            }
            else if(event.key == "PageDown")
            {
                monsterCameraRotation.down = 0;
            }
            else if(event.key == "0")
            {
                monsterAttacking = false;
            }

        }

        function rotateCamera(characterObject,characterCameraPivot,deltaX, deltaY)
        {
            characterObject.rotation.y += deltaX / 500;
            characterCameraPivot.rotation.x = THREE.MathUtils.clamp((characterCameraPivot.rotation.x + deltaY / 500),-0.66,-0.136);
        }

        function  resize()
        {
            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function setupPhysicsWorld()
        {
            const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
            const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
            const overlappingPairCache = new Ammo.btDbvtBroadphase();
            const solver = new Ammo.btSequentialImpulseConstraintSolver();

            physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher,overlappingPairCache,solver,collisionConfiguration);
            physicsWorld.setGravity(new Ammo.btVector3(0,-100,0));
        }

        function setupGraphics()
        {
            clock = new THREE.Clock();

            scene = new THREE.Scene();

            sky = new Sky();
            sky.scale.setScalar( 450000 );
            scene.add(sky);

            directionalLight = new THREE.DirectionalLight(0xffffff);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth,window.innerHeight);
            document.body.appendChild(renderer.domElement);

            renderer.shadowMap.enable = true;
            renderer.toneMappingExposure = effectController.exposure;
        }

        function createMap()
        {
            const loader = new GLTFLoader(loadingManager);
            loader.load(
                './assets/map.glb',
                function (gltf) {
                    scene.add( gltf.scene );
                },
                function (xhr) {
                },
                function (error) {
                    console.log( error );
                }
            );

            createWalls();
            createTreeColliders();
            createTreeLogColliders();
            createHouseCollider();
            createTorches();
        }

        function createPlane()
        {
            const pos = {x:0, y:-1, z:0};
            const scale = {x:800, y:2, z:800};
            const mass = 0;
            createBoxCollider(pos.x,pos.y,pos.z,scale.x,scale.y,scale.z,mass);
        }

        function createWalls()
        {
            createWall(0,0,90.24,300,300,1);
            createWall(0,0,-37.02,300,300,1);
            createWall(-100,0,0,1,300,300);
            createWall(70,0,0,1,300,300);
        }

        function createWall(posX,posY,posZ,scaleX,scaleY,scaleZ)
        {
            const mass = 0;
            createBoxCollider(posX,posY,posZ,scaleX,scaleY,scaleZ,mass);
        }

        function createTreeColliders()
        {
            const coords = [
                {x:-33,z:-10},
                {x:-33,z:26},
                {x:-44,z:40},
                {x:-28,z:54},
                {x:-12.5,z:68.5},
                {x:-21.5,z:82.5},
                {x:-29.9,z:70.4},
                {x:-44.3,z:75.4},
                {x:-44.3,z:60.0},
                {x:-58.4,z:67.2},
                {x:-73.8,z:73.9},
                {x:-73.8,z:56.8},
                {x:-60,z:49},
                {x:-72.9,z:35},
                {x:-89,z:35},
                {x:-89.4,z:17.7},
                {x:-74,z:-0.8},
                {x:-68,z:17},
                {x:-90,z:-0.7},
                {x:-71,z:-13},
                {x:-50,z:-12},
                {x:-59,z:3.4},
                {x:-43,z:9},
                {x:-54,z:27},
                {x:-12,z:-19.8},
                {x:8,z:-19},
                {x:24,z:-18},
                {x:24,z:-31},
                {x:39,z:-31.5},
                {x:54,z:-31.6}
            ]

            coords.forEach((coord) =>
            {
                createTreeCollider(coord.x,0,coord.z);
            });

        }

        function createTreeCollider(posX,posY,posZ)
        {
            const mass = 0;
            const radius = 1;
            const height = 20;
            createCapsuleCollider(posX,posY,posZ,mass,radius,height);
        }

        function createHouseCollider()
        {
            const pos = {x:61.5, y:15, z:12};
            const mass = 0;
            const radius = 13;
            const height = 20;
            createCapsuleCollider(pos.x,pos.y,pos.z,mass,radius,height);
        }

        function createTreeLogColliders()
        {
            const mass = 0;
            const radius = 0.5;
            const height = 3;
            const coords =
            [
                {x:-34.7,z:64.2},
                {x:-57,z:58},
                {x:-52.4,z:72.4},
                {x:-70,z:65},
                {x:-64,z:77.8},
                {x:-86.7,z:53.5},
                {x:-79.8,z:44.3},
                {x:-54.7,z:37.7},
                {x:-82,z:83.7},
                {x:-82.6,z:27.5},
                {x:-40.7,z:50.4},
                {x:-62,z:24.2},
                {x:-74,z:19},
                {x:-77.9,z:11.7},
                {x:85.3,z:7},
                {x:-72,z:6.72},
                {x:-62,z:12.4},
                {x:-49.27,z:14.31},
                {x:-49.35,z:-0.62},
                {x:-63.59,z:-7.8},
                {x:-82.43,z:-12.66},
                {x:-74.23,z:-28.98},
                {x:-61.94,z:-22.49},
                {x:-41.74,z:-20.25},
                {x:-52.35,z:67.74}
            ];

            coords.forEach((coord) =>
            {
                createCapsuleCollider(coord.x,0,coord.z,mass,radius,height);
            });
        }

        function createTreeLogCollider(posX,posY,posZ)
        {
            const mass = 0;
            const radius = 0.5;
            const height = 3;
            createCapsuleCollider(posX,posY,posZ,mass,radius,height);
        }

        function createTorches()
        {
            createTorch(-2,0,-16);
            createTorch(45.8,0,8.6);
            createTorch(45.8,0,18.8);
            createTorch(45.8,0,65);
            createTorch(-2,0,65);
            createTorch(-2,0,24.5);
        }

        function createTorch(posX,posY,posZ)
        {
            const loader = new GLTFLoader(loadingManager);
            loader.load(
            './assets/models/outdoor_torch.glb',
            function (gltf) {
                const model = gltf.scene;
                model.position.set(posX,posY + 4,posZ)
                model.scale.set(4,4,4);
                model.traverse(function(object)
                {
                    if(object.isMesh)
                        object.castShadow = true;
                });
                scene.add( model );
                const mass = 0;
                const radius = 0.1;
                const height = 13;
                createCapsuleCollider(posX,posY,posZ,mass,radius,height);

                const light = new THREE.PointLight(0xFBB741,2,70,4);
                light.position.set(posX,10 + posY,posZ);
                scene.add( light );

            },
            function (xhr) {
            },
            function (error) {
                console.log( error );
            }
            );
        }

        function resetCharacters()
        {
            const monsterInitPos = monsterPivot.userData.entityInitialPos;
            const humanInitPos = playerPivot.userData.entityInitialPos;

            monsterPivot.userData.physicsBody.getWorldTransform().setOrigin(new Ammo.btVector3(monsterInitPos.x,monsterInitPos.y,monsterInitPos.z));
            playerPivot.userData.physicsBody.getWorldTransform().setOrigin(new Ammo.btVector3(humanInitPos.x,humanInitPos.y,humanInitPos.z));

            playerObject.rotation.set(0,THREE.MathUtils.degToRad(-90),0);

            monsterObject.rotation.set(0,THREE.MathUtils.degToRad(90),0);

            playerDead = false;
            monsterDead = false;

            const dying = animationsMap.get("Dying");
            dying.stop();
            const idle = animationsMap.get("IDLE");
            idle.reset().play();
            animationPlaying = "IDLE";

            const monsterDying = monsterAnimationsMap.get("dying");
            monsterDying.stop();
            const monsterIdle = monsterAnimationsMap.get("IDLE");
            monsterIdle.reset().play();
            monsterAnimationPlaying = "IDLE";

            playerHealth = 100;
            monsterHealth = 100;

            document.getElementById("monsterHealth").style.width = "100%";
            document.getElementById("humanHealth").style.width = "100%";
        }

        function loadPlayer(posX,posY,posZ)
        {
            const loader = new GLTFLoader(loadingManager);
            loader.load(
                './assets/models/character.glb',
                function ( gltf ) {
                    const playerModel = gltf.scene;
                    playerModel.traverse(function(object)
                    {
                        if(object.isMesh)
                        {
                            object.castShadow = true;
                            object.receiveShadow = true;
                        }
                    });
                    createPlayer(posX,posY,posZ,playerModel);
                    playerMixer = new THREE.AnimationMixer(playerModel);
                    playerMixer.addEventListener('finished', ( event ) => {
                        animationFinished = true;
                        if(event.action.getClip().name == "Slash")
                            playerAttack()
                    });

                    gltf.animations.forEach((a) =>
                    {
                        animationsMap.set(a.name,playerMixer.clipAction(a));
                    });

                    const slashAnim = animationsMap.get("Slash");
                    slashAnim.setLoop(THREE.LoopOnce);
                    slashAnim.clampWhenFinished = true;
                    const action = animationsMap.get("IDLE");
                    animationPlaying = "IDLE";
                    action.play();
                    const dyingAnim = animationsMap.get("Dying");
                    dyingAnim.setLoop(THREE.LoopOnce);
                    dyingAnim.clampWhenFinished = true;
                },
                function ( xhr ) {
                },
                function ( error ) {

                    console.log( error );

                }
            );

        }

        function createPlayer(posX,posY,posZ,mesh)
        {
            const pos = {x:posX,y:posY,z:posZ};
            const scale = {x:3,y:3,z:3};
            const mass = 80;
            const radius = 1;
            const height = 1;

            playerObject = mesh;
            playerObject.scale.set(scale.x,scale.y,scale.z);
            playerObject.position.set(0,pos.y-1.5,0);
            playerPivot.add(playerObject);
            playerPivot.position.set(pos.x,pos.y,pos.z)
            playerObject.add(playerCameraPivot);

            playerCamera = new THREE.PerspectiveCamera(60,window.innerWidth / window.innerHeight,0.2,5000);
            playerCameraPivot.add(playerCamera);
            playerCamera.position.set(0,5,5);
            playerCamera.lookAt(new THREE.Vector3(pos.x,0,pos.z));
            playerCameraPivot.rotation.y += THREE.MathUtils.degToRad(180);

            playerObject.rotation.y += THREE.MathUtils.degToRad(-90);

            scene.add(playerPivot);

            const transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(pos.x,pos.y,pos.z));
            transform.setRotation(new Ammo.btQuaternion(0,0,0,1));
            const motionState = new Ammo.btDefaultMotionState(transform);
            const colShape = new Ammo.btCapsuleShape(radius,height);
            colShape.setMargin(0.05);
            const localInertia = new Ammo.btVector3(0,0,0);
            colShape.calculateLocalInertia(mass,localInertia);

            const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass,motionState,colShape,localInertia);
            const body = new Ammo.btRigidBody(rbInfo);
            body.setFriction(4);
            body.setRollingFriction(10);

            body.setActivationState( 4 );
            physicsWorld.addRigidBody(body);
            body.setAngularFactor(0);

            playerPivot.userData.physicsBody = body;
            playerPivot.userData.entityInitialPos = pos;
            rigidBodies.push(playerPivot);

        }

        function loadMonster(posX,posY,posZ)
        {
            const loader = new GLTFLoader(loadingManager);
            loader.load(
                './assets/models/monster.glb',
                function ( gltf ) {
                    const monsterModel = gltf.scene;
                    monsterModel.traverse(function(object)
                    {
                        if(object.isMesh)
                        {
                            object.castShadow = true;
                            object.receiveShadow = true;
                        }
                    });
                    createMonster(posX,posY,posZ,monsterModel);
                    monsterMixer = new THREE.AnimationMixer(monsterModel);
                    monsterMixer.addEventListener('finished', ( event ) => {
                        monsterAnimationFinished = true;
                        monsterIdleFinished = true;
                        if(event.action.getClip().name == "Attack")
                            monsterAttack();
                    });

                    gltf.animations.forEach((a) =>
                    {
                        monsterAnimationsMap.set(a.name,monsterMixer.clipAction(a));
                    });

                    const attackAnim = monsterAnimationsMap.get("Attack");
                    attackAnim.setLoop(THREE.LoopOnce);
                    attackAnim.clampWhenFinished = true;
                    const idleAnim = monsterAnimationsMap.get("IDLE");
                    idleAnim.setLoop(THREE.LoopOnce);
                    idleAnim.clampWhenFinished = true;
                    const idleAnim2 = monsterAnimationsMap.get("Breathing_IDLE");
                    idleAnim2.setLoop(THREE.LoopOnce);
                    idleAnim2.clampWhenFinished = true;
                    const dyingAnim = monsterAnimationsMap.get("dying");
                    dyingAnim.setLoop(THREE.LoopOnce);
                    dyingAnim.clampWhenFinished = true;
                },
                function ( xhr ) {
                },
                function ( error ) {

                    console.log( error );

                }
            );
        }

        function createMonster(posX,posY,posZ,mesh)
        {
            const pos = {x:posX,y:posY,z:posZ};
            const scale = {x:5,y:5,z:5};
            const mass = 80;
            const radius = 1;
            const height = 1;

            monsterObject = mesh;
            monsterObject.scale.set(scale.x,scale.y,scale.z);
            monsterObject.position.set(0,pos.y-1.5,0);
            monsterPivot.add(monsterObject);
            monsterPivot.position.set(pos.x,pos.y,pos.z);

            monsterObject.add(monsterCameraPivot);

            monsterCamera = new THREE.PerspectiveCamera(60,window.innerWidth / window.innerHeight,0.2,5000);
            monsterCameraPivot.add(monsterCamera);
            monsterCamera.position.set(0,5,5);
            monsterCamera.lookAt(new THREE.Vector3(pos.x,0,pos.z));
            monsterCameraPivot.rotation.y += THREE.MathUtils.degToRad(180);

            monsterObject.rotation.y += THREE.MathUtils.degToRad(90);

            scene.add(monsterPivot);

            const transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(pos.x,pos.y,pos.z));
            transform.setRotation(new Ammo.btQuaternion(0,0,0,1));
            const motionState = new Ammo.btDefaultMotionState(transform);
            const colShape = new Ammo.btCapsuleShape(radius,0.5);
            colShape.setMargin(0.05);
            const localInertia = new Ammo.btVector3(0,0,0);
            colShape.calculateLocalInertia(mass,localInertia);

            const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass,motionState,colShape,localInertia);
            const body = new Ammo.btRigidBody(rbInfo);
            body.setFriction(4);
            body.setRollingFriction(10);

            body.setActivationState( 4 );
            physicsWorld.addRigidBody(body);
            body.setAngularFactor(0);

            monsterPivot.userData.physicsBody = body;
            monsterPivot.userData.entityInitialPos = pos;
            rigidBodies.push(monsterPivot);
        }

        function createCapsuleCollider(posX,posY,posZ,mass,radius,height)
        {
            return createCollider(posX,posY,posZ,mass,new Ammo.btCapsuleShape(radius,height));
        }

        function createBoxCollider(posX,posY,posZ,scaleX,scaleY,scaleZ,mass)
        {
            return createCollider(posX,posY,posZ,mass,new Ammo.btBoxShape(new Ammo.btVector3(scaleX * 0.5,scaleY * 0.5,scaleZ * 0.5)));
        }

        function createCollider(posX,posY,posZ,mass,colShape)
        {
            const pos = {x:posX,y:posY,z:posZ};
            const transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(posX,posY,posZ));
            transform.setRotation(new Ammo.btQuaternion(0,0,0,1));

            const motionState = new Ammo.btDefaultMotionState(transform);

            const localInertia = new Ammo.btVector3(0,0,0);
            colShape.setMargin(0.05);
            colShape.calculateLocalInertia(mass,localInertia);

            const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass,motionState,colShape,localInertia);
            const body = new Ammo.btRigidBody(rbInfo);
            body.setFriction(4);
            body.setRollingFriction(10);
            physicsWorld.addRigidBody(body);
            return body;
        }

        function move(body,camera,running,attacking)
        {
            if(!(running && !attacking))
                return;

            const speed = 30;
            const characterPos = body.getWorldTransform().getOrigin();

            let direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize().multiplyScalar(speed);
            body.setLinearVelocity(new Ammo.btVector3(direction.x,0,direction.z));

        }

        function playerAttack()
        {
            if(monsterDead)
                return;

            const dir = monsterPivot.position.clone().sub(playerPivot.position).normalize();
            let dir2 = new THREE.Vector3();
            playerObject.getWorldDirection(dir2);

            //the dot  product is used to detect if the monster is in front of the human
            // > 0 if it is; < 0 if its not
            //the  > 0.8 is for the angle since the human is not suppose to do damage if the monster is parallel to him

            if(dir2.dot(dir) > 0.8 && playerPivot.position.distanceTo(monsterPivot.position) < 6.5)
            {
                monsterHealth = THREE.MathUtils.clamp(monsterHealth - playerDamage,0,100);
                document.getElementById("monsterHealth").style.width = monsterHealth + "%";
                if(monsterHealth == 0)
                {
                    monsterDead = true;
                    playerScore += 1;
                    document.getElementById("humanScore").innerHTML = playerScore;
                }
            }
        }

        function monsterAttack()
        {
            if(playerDead)
                return;

            const dir = playerPivot.position.clone().sub(monsterPivot.position).normalize();
            let dir2 = new THREE.Vector3();
            monsterObject.getWorldDirection(dir2);

            if(dir2.dot(dir) > 0.8 && monsterPivot.position.distanceTo(playerPivot.position) < 8)
            {
                playerHealth = THREE.MathUtils.clamp(playerHealth - monsterDamage,0,100);
                document.getElementById("humanHealth").style.width = playerHealth + "%";
                if(playerHealth == 0)
                {
                    playerDead = true;
                    monsterScore += 1;
                    document.getElementById("monsterScore").innerHTML = monsterScore;
                }
            }
        }

        function updatePhysics(deltaTime)
        {
            physicsWorld.stepSimulation(deltaTime,10);

            for(let i = 0; i < rigidBodies.length; i++)
            {
                const objThree = rigidBodies[i];
                const objAmmo = objThree.userData.physicsBody;
                const ms = objAmmo.getMotionState();

                if(ms)
                {
                    ms.getWorldTransform(ammoTmpTrans);
                    const p = ammoTmpTrans.getOrigin();
                    const q = ammoTmpTrans.getRotation();
                    objThree.position.set(p.x(),p.y(),p.z());
                    objThree.quaternion.set(q.x(),q.y(),q.z(),q.w());
                }
            }
        }

        function updateDayNightCycle(delta)
        {
            const speed = 10;
            const uniforms = sky.material.uniforms;
            const phi = THREE.MathUtils.degToRad(90 - effectController.elevation);
            const theta = THREE.MathUtils.degToRad(effectController.azimuth);

            sun.setFromSphericalCoords(1,phi,theta);

            uniforms['sunPosition'].value.copy(sun);
            directionalLight.position.copy(sun);
            effectController.elevation += delta * speed;
        }

        function updatePlayerMixer(delta)
        {
            if(animationFinished && ((!playerDead) || (playerDead && animationPlaying != "dying")))
            {
                const currentAnimation = animationsMap.get(animationPlaying);
                let nextAnimation,animationToPlay;

                if(playerDead)
                    animationToPlay = "Dying";
                else if(!playerRunning && !playerAttacking)
                    animationToPlay = "IDLE";
                else
                    animationToPlay = playerAttacking ? "Slash" : "Running.001";

                nextAnimation = animationsMap.get(animationToPlay);
                
                if(currentAnimation != nextAnimation)
                {
                    if(currentAnimation)
                        currentAnimation.fadeOut(0.5);
                    nextAnimation.reset().fadeIn(0.5).play();
                    animationPlaying = animationToPlay;
                }
                else if(animationToPlay == "Slash" && animationFinished)
                {
                    currentAnimation.reset();
                    animationFinished = false;
                }
            }

            if(playerMixer)
                playerMixer.update(delta)
        }

        function updateMonsterMixer(delta)
        {
            if(monsterAnimationFinished && ((!monsterDead) || (monsterDead && monsterAnimationPlaying != "dying")))
            {
                const currentAnimation = monsterAnimationsMap.get(monsterAnimationPlaying);
                let nextAnimation,animationToPlay = "";

                if(monsterDead)
                    animationToPlay = "dying";
                else if(!monsterRunning && !monsterAttacking)
                {
                    if(monsterIdleFinished)
                    {
                        const rnd = Math.floor(Math.random() * 3);
                        animationToPlay = rnd == 0 ? "IDLE" : "Breathing_IDLE";
                    }
                    else
                        animationToPlay = monsterAnimationPlaying;
                }
                else
                    animationToPlay = monsterAttacking ? "Attack" : "Walk";

                nextAnimation = monsterAnimationsMap.get(animationToPlay);
                if(!nextAnimation)
                    return;

                if(currentAnimation != nextAnimation)
                {
                    if(currentAnimation)
                        currentAnimation.fadeOut(0.5);

                    nextAnimation.reset().fadeIn(0.5).play();
                    monsterAnimationPlaying = animationToPlay;
                    monsterIdleFinished = true;
                }
                else if(((animationToPlay == "Attack" && monsterAnimationFinished) || ((animationToPlay == "IDLE" || animationToPlay == "Breathing_IDLE") && monsterIdleFinished)))
                {
                    if(currentAnimation)
                        currentAnimation.reset();

                    if(animationToPlay == "Attack")
                        monsterAnimationFinished = false;
                    else
                        monsterIdleFinished = false;
                }
            }

            if(monsterMixer)
                monsterMixer.update(delta)
        }

        function render(camera,left)
        {
            const bottom = Math.floor(window.innerHeight * 0);
            const width = Math.floor(window.innerWidth * 0.5);
            const height = Math.floor(window.innerHeight * 1);

            renderer.setViewport(left,bottom,width,height);
            renderer.setScissor(left,bottom,width,height);
            renderer.setScissorTest(true);

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.render(scene,camera);
        }

        function updateCameraRotation(characterObject,cameraPivot,cameraRotation)
        {
            const cameraSpeed = 10;
            const deltaX = (cameraRotation.right - cameraRotation.left) * cameraSpeed;
            const deltaY = (cameraRotation.up - cameraRotation.down) * cameraSpeed;
            rotateCamera(characterObject,cameraPivot,deltaX,deltaY);
        }

        let timePassedSinceDeath = 0;
        const timeUntilReset = 5;
        function renderFrame()
        {
            let deltaTime = clock.getDelta();
            if(!playerDead && playerObject)
            {
                move(playerPivot.userData.physicsBody,playerCamera,playerRunning,!animationFinished);
                updateCameraRotation(playerObject,playerCameraPivot,playerCameraRotation);
            }

            if(!monsterDead && monsterObject)
            {
                move(monsterPivot.userData.physicsBody,monsterCamera,monsterRunning,!monsterAnimationFinished);
                updateCameraRotation(monsterObject,monsterCameraPivot,monsterCameraRotation);
            }
                
            updatePhysics(deltaTime);
            updatePlayerMixer(deltaTime);
            updateMonsterMixer(deltaTime);
            updateDayNightCycle(deltaTime);

            if(playerCamera)
                render(playerCamera,Math.floor(window.innerWidth * 0));
            if(monsterCamera)
                render(monsterCamera,Math.floor(window.innerWidth * 0.5));

            if(playerDead || monsterDead)
            {
                timePassedSinceDeath += deltaTime;
            }

            if(timePassedSinceDeath >= timeUntilReset)
            {
                timePassedSinceDeath = 0;
                resetCharacters();
            }

            requestAnimationFrame(renderFrame);
        }
    </script>
</body>
</html>